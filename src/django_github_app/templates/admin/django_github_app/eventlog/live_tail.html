{% extends "admin/base_site.html" %}
{% load i18n admin_urls static %}

{% block title %}{{ title }} | {{ site_title|default:_('Django site admin') }}{% endblock %}

{% block branding %}
<h1 id="site-name"><a href="{% url 'admin:index' %}">{{ site_header|default:_('Django administration') }}</a></h1>
{% endblock %}

{% block nav-breadcrumbs %}
<div class="breadcrumbs">
<a href="{% url 'admin:index' %}">{% translate 'Home' %}</a>
&rsaquo; <a href="{% url 'admin:app_list' app_label=opts.app_label %}">{{ opts.app_config.verbose_name }}</a>
&rsaquo; <a href="{% url opts|admin_urlname:'changelist' %}">{{ opts.verbose_name_plural|capfirst }}</a>
&rsaquo; {{ title }}
</div>
{% endblock %}

{% block content %}
<div class="live-tail-container">
    <div class="live-tail-header">
        <div class="status-section">
            <span class="connection-status" id="status">Connecting...</span>
            <span class="queue-info" id="queue-info"></span>
        </div>
        <div class="controls">
            <button id="pause-btn" class="button">Pause</button>
            <button id="clear-btn" class="button">Clear</button>
        </div>
    </div>
    
    <div class="live-tail-output" id="events-container">
        <!-- Events will be displayed here -->
    </div>
</div>

<style>
.live-tail-container {
    margin: 20px 0;
    background: var(--body-bg, #121212);
    color: var(--body-fg, #eeeeee);
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 12px;
    border: 1px solid var(--border-color, #353535);
    border-radius: 4px;
}

.live-tail-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    background: var(--darkened-bg, #212121);
    border-bottom: 1px solid var(--border-color, #353535);
    color: var(--body-fg, #eeeeee);
}

.status-section {
    display: flex;
    gap: 15px;
    align-items: center;
}

.controls {
    display: flex;
    gap: 10px;
    align-items: center;
}

.queue-info {
    font-size: 12px;
    color: var(--body-quiet-color, #d0d0d0);
    font-style: italic;
}

.controls button {
    padding: 5px 10px;
    font-size: 12px;
    background: var(--close-button-bg, #333333);
    color: var(--body-fg, #eeeeee);
    border: 1px solid var(--border-color, #353535);
    border-radius: 3px;
    cursor: pointer;
}

.controls button:hover {
    background: var(--close-button-hover-bg, #666666);
}

.connection-status {
    font-size: 12px;
    padding: 3px 8px;
    border-radius: 3px;
    background: var(--message-warning-bg, #583305);
    color: var(--body-fg, #eeeeee);
}

.connection-status.connected {
    background: var(--message-success-bg, #006b1b);
    color: var(--body-fg, #eeeeee);
}

.connection-status.error {
    background: var(--message-error-bg, #570808);
    color: var(--error-fg, #e35f5f);
}

.live-tail-output {
    height: 600px;
    overflow-y: auto;
    padding: 15px;
    line-height: 1.4;
    word-break: break-word;
    background: var(--body-bg, #121212);
}

.event-entry {
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--hairline-color, #272727);
}

.event-meta {
    color: var(--body-quiet-color, #d0d0d0);
    margin-bottom: 5px;
    font-size: 11px;
}

.event-type {
    color: var(--link-fg, #81d4fa);
    font-weight: bold;
}

.event-action {
    color: var(--body-medium-color, #e0e0e0);
}

.event-payload {
    margin-top: 8px;
    padding: 8px;
    background: var(--selected-bg, #1b1b1b);
    border: 1px solid var(--hairline-color, #272727);
    border-radius: 3px;
    white-space: pre-wrap;
    font-size: 11px;
    max-height: 200px;
    overflow-y: auto;
    color: var(--body-quiet-color, #d0d0d0);
}
</style>

<script src="https://unpkg.com/htmx.org@1.9.10"></script>
<script>
let eventSource = null;
let pageLoadTime = new Date().toISOString();
let isPaused = false;
let isConnected = false;
let eventQueue = [];
let pauseTimer = null;

const PAUSE_TIMEOUT = 5 * 60 * 1000; // 5 minutes in milliseconds

const statusEl = document.getElementById('status');
const queueInfoEl = document.getElementById('queue-info');
const pauseBtn = document.getElementById('pause-btn');
const clearBtn = document.getElementById('clear-btn');
const container = document.getElementById('events-container');

function updateStatus(status, className) {
    statusEl.textContent = status;
    statusEl.className = 'connection-status ' + className;
}

function updatePauseButton() {
    if (!isConnected) {
        pauseBtn.textContent = 'Reconnect';
        pauseBtn.disabled = false;
        queueInfoEl.textContent = '';
    } else if (isPaused) {
        pauseBtn.textContent = 'Resume';
        if (eventQueue.length > 0) {
            queueInfoEl.textContent = `${eventQueue.length} queued`;
        } else {
            queueInfoEl.textContent = '';
        }
    } else {
        pauseBtn.textContent = 'Pause';
        queueInfoEl.textContent = '';
    }
}

function startPauseTimer() {
    if (pauseTimer) {
        clearTimeout(pauseTimer);
    }
    
    pauseTimer = setTimeout(() => {
        // Auto-disconnect after timeout
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }
        isConnected = false;
        isPaused = false;
        eventQueue = []; // Clear queue on disconnect
        updateStatus('Disconnected', 'error');
        updatePauseButton();
    }, PAUSE_TIMEOUT);
}

function cancelPauseTimer() {
    if (pauseTimer) {
        clearTimeout(pauseTimer);
        pauseTimer = null;
    }
}

function drainEventQueue() {
    while (eventQueue.length > 0) {
        const eventData = eventQueue.shift();
        addEventToDOM(eventData);
    }
    updatePauseButton();
}

// Recursively sort object keys (case-insensitive) - matches admin JSON formatting
function sortObject(obj, depth = 0) {
    if (depth > 100) return obj;

    if (obj === null || typeof obj !== 'object') {
        return obj;
    }

    if (Array.isArray(obj)) {
        return obj.map(item => sortObject(item, depth + 1));
    }

    return Object.keys(obj)
        .sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()))
        .reduce((sorted, key) => {
            sorted[key] = sortObject(obj[key], depth + 1);
            return sorted;
        }, {});
}

function formatEvent(eventData) {
    const timestamp = new Date(eventData.received_at).toLocaleString();
    const eventType = eventData.event || 'unknown';
    const action = eventData.action ? ':' + eventData.action : '';
    
    // Sort the payload keys to match admin interface formatting
    let payload = '';
    if (eventData.payload) {
        try {
            const sortedPayload = sortObject(eventData.payload);
            payload = JSON.stringify(sortedPayload, null, 2);
        } catch (e) {
            payload = JSON.stringify(eventData.payload, null, 2);
        }
    }
    
    return `
        <div class="event-entry">
            <div class="event-meta">
                [${timestamp}] ID: ${eventData.id}
            </div>
            <div>
                <span class="event-type">${eventType}</span><span class="event-action">${action}</span>
            </div>
            ${payload ? `<div class="event-payload">${payload}</div>` : ''}
        </div>
    `;
}

function addEventToDOM(eventData) {
    if (!eventData.id) return;
    
    const eventHtml = formatEvent(eventData);
    container.insertAdjacentHTML('afterbegin', eventHtml);
    
    // Keep only the latest 50 events
    const events = container.querySelectorAll('.event-entry');
    if (events.length > 50) {
        for (let i = 50; i < events.length; i++) {
            events[i].remove();
        }
    }
}

function addEvent(eventData) {
    if (!eventData.id) return;
    
    if (isPaused) {
        // Queue the event instead of displaying it
        eventQueue.push(eventData);
        updatePauseButton();
        return;
    }
    
    addEventToDOM(eventData);
}

function startSSE() {
    if (eventSource) {
        eventSource.close();
    }
    
    updateStatus('Connecting...', '');
    
    const streamUrl = new URL('stream/', window.location.href);
    streamUrl.searchParams.set('since', pageLoadTime);
    
    eventSource = new EventSource(streamUrl.toString());
    
    eventSource.onopen = function() {
        isConnected = true;
        updateStatus('Connected', 'connected');
        updatePauseButton();
    };
    
    eventSource.onmessage = function(event) {
        try {
            const eventData = JSON.parse(event.data);
            if (eventData.id) {
                addEvent(eventData); // addEvent handles pausing internally now
            }
        } catch (e) {
            console.error('Error parsing event data:', e);
        }
    };
    
    eventSource.onerror = function() {
        isConnected = false;
        updateStatus('Connection Error - Retrying...', 'error');
        updatePauseButton();
        setTimeout(() => {
            if (!isPaused) {
                startPolling();
            }
        }, 3000);
    };
}

function startPolling() {
    if (eventSource) {
        eventSource.close();
        eventSource = null;
    }
    
    isConnected = true;
    updateStatus('Polling...', 'connected');
    updatePauseButton();
    
    const poll = () => {
        if (isPaused) {
            setTimeout(poll, 2000);
            return;
        }
        
        const streamUrl = new URL('stream/', window.location.href);
        streamUrl.searchParams.set('since', pageLoadTime);
        
        fetch(streamUrl.toString())
            .then(response => {
                if (!response.ok) throw new Error('Network error');
                return response.text();
            })
            .then(text => {
                const lines = text.split('\n');
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const eventData = JSON.parse(line.substring(6));
                            if (eventData.id) {
                                addEvent(eventData); // addEvent handles pausing internally
                            }
                        } catch (e) {
                            // Ignore parse errors
                        }
                    }
                }
                setTimeout(poll, 2000);
            })
            .catch(() => {
                isConnected = false;
                updateStatus('Polling Error - Retrying...', 'error');
                updatePauseButton();
                setTimeout(poll, 5000);
            });
    };
    
    setTimeout(poll, 1000);
}

// Event listeners
pauseBtn.addEventListener('click', function() {
    if (!isConnected) {
        // Reconnect
        eventQueue = [];
        isPaused = false;
        pageLoadTime = new Date().toISOString(); // Reset to current time
        if (typeof EventSource !== 'undefined') {
            startSSE();
        } else {
            startPolling();
        }
        return;
    }
    
    if (isPaused) {
        // Resume: drain queue and continue
        isPaused = false;
        cancelPauseTimer();
        drainEventQueue();
        updateStatus('Connected', 'connected');
    } else {
        // Pause: start queuing events
        isPaused = true;
        startPauseTimer();
        updateStatus('Paused', '');
    }
    
    updatePauseButton();
});

clearBtn.addEventListener('click', function() {
    container.innerHTML = '';
    // Also clear the queue if paused
    eventQueue = [];
    updatePauseButton();
});

// Start with SSE, fallback to polling
if (typeof EventSource !== 'undefined') {
    startSSE();
} else {
    startPolling();
}

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (eventSource) {
        eventSource.close();
    }
    if (pauseTimer) {
        clearTimeout(pauseTimer);
    }
});
</script>
{% endblock %}