{% extends "admin/base_site.html" %}
{% load i18n admin_urls static %}

{% block title %}{{ title }} | {{ site_title|default:_('Django site admin') }}{% endblock %}

{% block branding %}
<h1 id="site-name"><a href="{% url 'admin:index' %}">{{ site_header|default:_('Django administration') }}</a></h1>
{% endblock %}

{% block nav-breadcrumbs %}
<div class="breadcrumbs">
<a href="{% url 'admin:index' %}">{% translate 'Home' %}</a>
&rsaquo; <a href="{% url 'admin:app_list' app_label=opts.app_label %}">{{ opts.app_config.verbose_name }}</a>
&rsaquo; <a href="{% url opts|admin_urlname:'changelist' %}">{{ opts.verbose_name_plural|capfirst }}</a>
&rsaquo; {{ title }}
</div>
{% endblock %}

{% block content %}
<div class="live-tail-container">
    <div class="live-tail-header">
        <div class="status-section">
            <span class="connection-status" id="status">Connecting...</span>
            <span class="queue-info" id="queue-info"></span>
        </div>
        <div class="controls">
            <button id="pause-btn" class="button">Pause</button>
            <button id="clear-btn" class="button">Clear</button>
        </div>
    </div>
    
    <div class="live-tail-output" id="events-container">
        <!-- Events will be displayed here -->
    </div>
</div>

<style>
.live-tail-container {
    margin: 20px 0;
    background: var(--body-bg);
    color: var(--body-fg);
    font-family: var(--font-family-monospace);
    font-size: 12px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
}

.live-tail-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    background: var(--darkened-bg);
    border-bottom: 1px solid var(--border-color);
    color: var(--body-fg);
}

.status-section {
    display: flex;
    gap: 15px;
    align-items: center;
}

.controls {
    display: flex;
    gap: 10px;
    align-items: center;
}

.queue-info {
    font-size: 12px;
    color: var(--body-quiet-color);
    font-style: italic;
}

.controls button {
    padding: 8px 12px;
    font-size: 13px;
    font-weight: normal;
    background: var(--button-bg);
    color: var(--button-fg);
    border: none;
    border-radius: 4px;
    cursor: pointer;
    text-decoration: none;
    display: inline-block;
    font-family: var(--font-family-primary);
    line-height: normal;
}

.controls button:hover,
.controls button:focus {
    background: var(--button-hover-bg);
}

.controls button:active {
    background: var(--default-button-hover-bg);
}

.connection-status {
    font-size: 12px;
    padding: 3px 8px;
    border-radius: 3px;
    background: var(--message-warning-bg);
    color: var(--body-fg);
}

.connection-status.connected {
    background: var(--message-success-bg);
    color: var(--body-fg);
}

.connection-status.error {
    background: var(--message-error-bg);
    color: var(--error-fg);
}

.live-tail-output {
    height: 600px;
    overflow-y: auto;
    padding: 15px;
    line-height: 1.4;
    word-break: break-word;
    background: var(--body-bg);
}

.event-entry {
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--hairline-color);
    transition: background-color 0.8s ease-out;
}

.event-entry.new-event {
    /* Light mode: start darker than normal */
    background-color: var(--selected-bg);
}

/* Dark mode: start lighter than normal */
html[data-theme="dark"] .event-entry.new-event,
@media (prefers-color-scheme: dark) {
    .event-entry.new-event {
        background-color: var(--darkened-bg);
    }
}

.event-meta {
    color: var(--body-quiet-color);
    margin-bottom: 5px;
    font-size: 11px;
}

.event-type {
    color: var(--link-fg);
    font-weight: bold;
}

.event-action {
    color: var(--body-medium-color);
}

.event-payload {
    margin-top: 8px;
    padding: 8px;
    background: var(--selected-bg);
    border: 1px solid var(--hairline-color);
    border-radius: 3px;
    white-space: pre-wrap;
    font-size: 11px;
    max-height: 200px;
    overflow-y: auto;
    color: var(--body-quiet-color);
}
</style>

<script src="https://unpkg.com/htmx.org@1.9.10"></script>
<script>
let eventSource = null;
let pageLoadTime = new Date().toISOString();
let isPaused = false;
let isConnected = false;
let eventQueue = [];
let pauseTimer = null;

const PAUSE_TIMEOUT = 5 * 60 * 1000; // 5 minutes in milliseconds

const statusEl = document.getElementById('status');
const queueInfoEl = document.getElementById('queue-info');
const pauseBtn = document.getElementById('pause-btn');
const clearBtn = document.getElementById('clear-btn');
const container = document.getElementById('events-container');

// Create intersection observer for animations
const animationObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting && entry.target.classList.contains('new-event')) {
            // Only remove the class (trigger animation) when visible
            setTimeout(() => {
                entry.target.classList.remove('new-event');
            }, 50);
        }
    });
}, {
    root: container, // Observe within the scroll container
    threshold: 0.1   // Trigger when 10% visible
});

function updateStatus(status, className) {
    statusEl.textContent = status;
    statusEl.className = 'connection-status ' + className;
}

function updatePauseButton() {
    if (!isConnected) {
        pauseBtn.textContent = 'Reconnect';
        pauseBtn.disabled = false;
        queueInfoEl.textContent = '';
    } else if (isPaused) {
        pauseBtn.textContent = 'Resume';
        if (eventQueue.length > 0) {
            queueInfoEl.textContent = `${eventQueue.length} queued`;
        } else {
            queueInfoEl.textContent = '';
        }
    } else {
        pauseBtn.textContent = 'Pause';
        queueInfoEl.textContent = '';
    }
}

function startPauseTimer() {
    if (pauseTimer) {
        clearTimeout(pauseTimer);
    }
    
    pauseTimer = setTimeout(() => {
        // Auto-disconnect after timeout
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }
        isConnected = false;
        isPaused = false;
        eventQueue = []; // Clear queue on disconnect
        updateStatus('Disconnected', 'error');
        updatePauseButton();
    }, PAUSE_TIMEOUT);
}

function cancelPauseTimer() {
    if (pauseTimer) {
        clearTimeout(pauseTimer);
        pauseTimer = null;
    }
}

function drainEventQueue() {
    if (eventQueue.length === 0) return;
    
    const calculateDelay = () => {
        // Speed up based on queue size
        if (eventQueue.length > 50) return 20;  // Very fast for large backlogs
        if (eventQueue.length > 20) return 50;  // Fast
        if (eventQueue.length > 5) return 75;   // Medium
        return 100; // Normal speed for small queues
    };
    
    const drainNext = () => {
        if (eventQueue.length > 0 && !isPaused) {
            const eventData = eventQueue.shift();
            addEventToDOM(eventData);
            updatePauseButton();
            
            // Continue draining with adaptive delay
            if (eventQueue.length > 0) {
                setTimeout(drainNext, calculateDelay());
            }
        }
    };
    
    drainNext();
}

// Recursively sort object keys (case-insensitive) - matches admin JSON formatting
function sortObject(obj, depth = 0) {
    if (depth > 100) return obj;

    if (obj === null || typeof obj !== 'object') {
        return obj;
    }

    if (Array.isArray(obj)) {
        return obj.map(item => sortObject(item, depth + 1));
    }

    return Object.keys(obj)
        .sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()))
        .reduce((sorted, key) => {
            sorted[key] = sortObject(obj[key], depth + 1);
            return sorted;
        }, {});
}

function formatEvent(eventData) {
    const timestamp = new Date(eventData.received_at).toLocaleString();
    const eventType = eventData.event || 'unknown';
    const action = eventData.action ? ':' + eventData.action : '';
    
    // Sort the payload keys to match admin interface formatting
    let payload = '';
    if (eventData.payload) {
        try {
            const sortedPayload = sortObject(eventData.payload);
            payload = JSON.stringify(sortedPayload, null, 2);
        } catch (e) {
            payload = JSON.stringify(eventData.payload, null, 2);
        }
    }
    
    return `
        <div class="event-entry">
            <div class="event-meta">
                [${timestamp}] ID: ${eventData.id}
            </div>
            <div>
                <span class="event-type">${eventType}</span><span class="event-action">${action}</span>
            </div>
            ${payload ? `<div class="event-payload">${payload}</div>` : ''}
        </div>
    `;
}

function addEventToDOM(eventData) {
    if (!eventData.id) return;
    
    const eventHtml = formatEvent(eventData);
    container.insertAdjacentHTML('afterbegin', eventHtml);
    
    // Get the newly added element and add animation class
    const newEvent = container.firstElementChild;
    newEvent.classList.add('new-event');
    
    // Observe this element for visibility-based animation
    animationObserver.observe(newEvent);
    
    // Keep only the latest 50 events
    const events = container.querySelectorAll('.event-entry');
    if (events.length > 50) {
        for (let i = 50; i < events.length; i++) {
            // Clean up observer for removed elements
            animationObserver.unobserve(events[i]);
            events[i].remove();
        }
    }
}

function addEvent(eventData) {
    if (!eventData.id) return;
    
    if (isPaused) {
        // Queue the event instead of displaying it
        eventQueue.push(eventData);
        updatePauseButton();
        return;
    }
    
    addEventToDOM(eventData);
}

function startSSE() {
    if (eventSource) {
        eventSource.close();
    }
    
    updateStatus('Connecting...', '');
    
    const streamUrl = new URL('stream/', window.location.href);
    streamUrl.searchParams.set('since', pageLoadTime);
    
    eventSource = new EventSource(streamUrl.toString());
    
    eventSource.onopen = function() {
        isConnected = true;
        updateStatus('Connected', 'connected');
        updatePauseButton();
    };
    
    eventSource.onmessage = function(event) {
        try {
            const eventData = JSON.parse(event.data);
            if (eventData.id) {
                addEvent(eventData); // addEvent handles pausing internally now
            }
        } catch (e) {
            console.error('Error parsing event data:', e);
        }
    };
    
    eventSource.onerror = function() {
        isConnected = false;
        updateStatus('Connection Error - Retrying...', 'error');
        updatePauseButton();
        setTimeout(() => {
            if (!isPaused) {
                startPolling();
            }
        }, 3000);
    };
}

function startPolling() {
    if (eventSource) {
        eventSource.close();
        eventSource = null;
    }
    
    isConnected = true;
    updateStatus('Polling...', 'connected');
    updatePauseButton();
    
    const poll = () => {
        if (isPaused) {
            setTimeout(poll, 2000);
            return;
        }
        
        const streamUrl = new URL('stream/', window.location.href);
        streamUrl.searchParams.set('since', pageLoadTime);
        
        fetch(streamUrl.toString())
            .then(response => {
                if (!response.ok) throw new Error('Network error');
                return response.text();
            })
            .then(text => {
                const lines = text.split('\n');
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const eventData = JSON.parse(line.substring(6));
                            if (eventData.id) {
                                addEvent(eventData); // addEvent handles pausing internally
                            }
                        } catch (e) {
                            // Ignore parse errors
                        }
                    }
                }
                setTimeout(poll, 2000);
            })
            .catch(() => {
                isConnected = false;
                updateStatus('Polling Error - Retrying...', 'error');
                updatePauseButton();
                setTimeout(poll, 5000);
            });
    };
    
    setTimeout(poll, 1000);
}

// Event listeners
pauseBtn.addEventListener('click', function() {
    if (!isConnected) {
        // Reconnect
        eventQueue = [];
        isPaused = false;
        pageLoadTime = new Date().toISOString(); // Reset to current time
        if (typeof EventSource !== 'undefined') {
            startSSE();
        } else {
            startPolling();
        }
        return;
    }
    
    if (isPaused) {
        // Resume: drain queue and continue
        isPaused = false;
        cancelPauseTimer();
        drainEventQueue();
        updateStatus('Connected', 'connected');
    } else {
        // Pause: start queuing events
        isPaused = true;
        startPauseTimer();
        updateStatus('Paused', '');
    }
    
    updatePauseButton();
});

clearBtn.addEventListener('click', function() {
    // Clean up all observers before clearing
    const events = container.querySelectorAll('.event-entry');
    events.forEach(event => animationObserver.unobserve(event));
    
    container.innerHTML = '';
    // Also clear the queue if paused
    eventQueue = [];
    updatePauseButton();
});

// Start with SSE, fallback to polling
if (typeof EventSource !== 'undefined') {
    startSSE();
} else {
    startPolling();
}

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (eventSource) {
        eventSource.close();
    }
    if (pauseTimer) {
        clearTimeout(pauseTimer);
    }
    // Clean up intersection observer
    animationObserver.disconnect();
});
</script>
{% endblock %}